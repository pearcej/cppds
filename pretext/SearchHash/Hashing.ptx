<section xml:id="search-hash_hashing">
        <title>Hashing</title>
        
        <p>In previous sections we were able to make improvements on our search
            algorithms by taking advantage of information about where items are
            stored in the collection with respect to one another. For example, by
            knowing that a list was ordered, we could search in logarithmic time
            using a binary search. In this section we will attempt to go one step
            further by building a data structure that can be searched in
            <m>O(1)</m> by using <term>hashing</term>.<idx>hashing</idx></p> 
        <p>In order to do this, we will need to know even more about where the
            items might be when we go to look for them in the collection. If every
            item is where it should be, then the search can use a single comparison
            to discover the presence of an item. We will see, however, that this is
            typically not the case.</p>
        
        <p>A <term>hash table</term> is a collection of items which are stored in such a way
            as to make it easy to find them later. Each position of the hash table,
            often called a <term>slot</term>, can hold an item and is named by an integer
            value starting at 0.<idx>hash table</idx> For example, we will have a slot named 0, a slot
            named 1, a slot named 2, and so on.<idx>slot</idx>Initially, the hash table contains
            no items so every slot is empty. We can implement a hash table by using
            a list with each value initialized to an empty string.
            <xref ref="fig-hashtable1"/> shows a hash table of size <m>m=11</m>.
            In other words, there are <em>m</em> slots in the table, named 0 through 10.</p>
        
        <blockquote>
            <figure align="center" xml:id="fig-hashtable">
                <caption>Hash Table with 11 Empty Slots</caption>
                    <image source="SearchHash/hashtable.png" width="80%">
                    <description>Image depicting a hash table data structure with eleven empty slots. The slots are numbered from 0 to 10 and each contains the word 'None', indicating that they are unoccupied. The table is presented in a horizontal format, with clear delineation between each slot.</description>
                    </image>
                </figure>
        </blockquote>


        
        <p>In a hash table, the mapping between an item and the slot where that item belongs in the
            hash table is called the <term>hash function</term>.<idx>hash function</idx> The hash function will take
            any item in the collection and return an integer in the range of slot
            names, between 0 and <em>m</em>-1. Assume that we have the set of integer items
            54, 26, 93, 17, 77, and 31. Our first hash function, sometimes referred
            to as the <q>remainder method,</q> simply takes an item and divides it by the
            table size, returning the remainder as its hash value
            (<m>h(item)=item \% 11</m>). <xref ref="search-hash_search-hash_tbl-hashvalues1"/> gives all of the
            hash values for our example items. Note that this remainder method
            (modulo arithmetic) will typically be present in some form in all hash
            functions, since the result must be in the range of slot names.</p>
        
        <table xml:id="search-hash_id2"><tabular>
            <title><term>Table 4: Simple Hash Function Using Remainders</term></title>
            
                
                
                
                    <row header="yes">
                        <cell>
                            <term>Item</term>
                        </cell>
                        <cell>
                            <term>Hash Value</term>
                        </cell>
                    </row>
                
                
                    <row>
                        <cell>
                            54
                        </cell>
                        <cell>
                            10
                        </cell>
                    </row>
                    <row>
                        <cell>
                            26
                        </cell>
                        <cell>
                            4
                        </cell>
                    </row>
                    <row>
                        <cell>
                            93
                        </cell>
                        <cell>
                            5
                        </cell>
                    </row>
                    <row>
                        <cell>
                            17
                        </cell>
                        <cell>
                            6
                        </cell>
                    </row>
                    <row>
                        <cell>
                            77
                        </cell>
                        <cell>
                            0
                        </cell>
                    </row>
                    <row>
                        <cell>
                            31
                        </cell>
                        <cell>
                            9
                        </cell>
                    </row>
                
            
        </tabular></table>
        <p>Once the hash values have been computed, we can insert each item into
            the hash table at the designated position as shown in
            <xref ref="fig-hashtable2"/>. Note that 6 of the 11 slots are now occupied. This
            is referred to as the <term>load factor</term>, and is commonly denoted by
            <m>\lambda = \frac {numberofitems}{tablesize}</m>. For this example,
            <m>\lambda = \frac {6}{11}</m>.<idx>load factor</idx></p>
        
        <figure align="center" xml:id="fig-hashtable2">
            <caption> Hash Table with Six Items</caption>
                <image source="SearchHash/hashtable2.png" width="80%">
                <description>Image showing a hash table with eleven slots, numbered from 0 to 10. Some slots contain integers while others are empty. Starting from the left, slot 0 contains '77', slot 4 contains '26', slot 5 contains '93', slot 6 contains '17', slot 9 contains '31', and slot 10 contains '54'. Slots 1, 2, 3, 7, and 8 are labeled 'None', indicating they are unoccupied. </description>
                </image>
            </figure>
        <p>Now when we want to search for an item, we simply use the hash function
            to compute the slot name for the item and then check the hash table to
            see if it is present. This searching operation is <m>O(1)</m>, since
            a constant amount of time is required to compute the hash value and then
            index the hash table at that location. If everything is where it should
            be, we have found a constant time search algorithm.</p>
        
        <p>You can probably already see that this technique is going to work only
            if each item maps to a unique location in the hash table. For example,
            if the item 44 had been the next item in our collection, it would have a
            hash value of 0 (<m>44 \% 11 == 0</m>). Since 77 also had a hash
            value of 0, we would have a problem. According to the hash function, two
            or more items would need to be in the same slot.This is referred to as
            a <term>collision</term> (it may also be called a <q>clash</q>). <idx>collision</idx> Clearly, collisions
            create a problem for the hashing technique. We will discuss them in
            detail later.</p>
        <subsection xml:id="search-hash_hash-functions">
            <title>Hash Functions</title>
            
            <p>Given a collection of items, a hash function that maps each item into a
                unique slot is referred to as a <term>perfect hash function</term>.<idx>perfect hash function</idx>If we know
                the items and the collection will never change, then it is possible to
                construct a perfect hash function (refer to the exercises for more about
                perfect hash functions). Unfortunately, given an arbitrary collection of
                items, there is no systematic way to construct a perfect hash function.
                Luckily, we do not need the hash function to be perfect to still gain
                performance efficiency.</p>
            <p>One way to always have a perfect hash function is to increase the size
                of the hash table so that each possible value in the item range can be
                accommodated. This guarantees that each item will have a unique slot.
                Although this is practical for small numbers of items, it is not
                feasible when the number of possible items is large. For example, if the
                items were nine-digit Social Security numbers, this method would require
                almost one billion slots. If we only want to store data for a class of
                25 students, we will be wasting an enormous amount of memory.</p>
            <p>Our goal is to create a hash function that minimizes the number of
                collisions, is easy to compute, and evenly distributes the items in the
                hash table. There are a number of common ways to extend the simple
                remainder method. We will consider a few of them here.</p>
            
            <p>The <term>folding method</term> for constructing hash functions begins by
                dividing the item into equal-size pieces (the last piece may not be of
                equal size).<idx>folding method</idx>These pieces are then added together to give the resulting
                hash value. For example, if our item was the phone number 436-555-4601,
                we would take the digits and divide them into groups of 2
                (43,65,55,46,01). After the addition, <m>43+65+55+46+01</m>, we get
                210. If we assume our hash table has 11 slots, then we need to perform
                the extra step of dividing by 11 and keeping the remainder. In this case
                <m>210\ \%\ 11</m> is 1, so the phone number 436-555-4601 hashes to
                slot 1. Some folding methods go one step further and reverse every other
                piece before the addition. For the above example, we get
                <m>43+56+55+64+01 = 219</m> which gives <m>219\ \%\ 11 = 10</m>.</p>
            
            <p>Another numerical technique for constructing a hash function is called 
                the <term>mid-square method</term>.<idx>mid-square method</idx> We first square the item, and then extract
                some portion of the resulting digits. For example, if the item were 44,
                we would first compute <m>44 ^{2} = 1,936</m>. By extracting the
                middle two digits, 93, and performing the remainder step, we get 5
                (<m>93\ \%\ 11</m>). <xref ref="search-hash_tbl-hashvalues2"/> shows items under both the
                remainder method and the mid-square method. You should verify that you
                understand how these values were computed.</p>
            
            <table xml:id="search-hash_id4"><tabular>
                <title><term>Table 5: Comparison of Remainder and Mid-Square Methods</term></title>
                
                    
                    
                    
                    
                        <row header="yes">
                            <cell>
                                <term>Item</term>
                            </cell>
                            <cell>
                                <term>Remainder</term>
                            </cell>
                            <cell>
                                <term>Mid-Square</term>
                            </cell>
                        </row>
                    
                    
                        <row>
                            <cell>
                                54
                            </cell>
                            <cell>
                                10
                            </cell>
                            <cell>
                                3
                            </cell>
                        </row>
                        <row>
                            <cell>
                                26
                            </cell>
                            <cell>
                                4
                            </cell>
                            <cell>
                                7
                            </cell>
                        </row>
                        <row>
                            <cell>
                                93
                            </cell>
                            <cell>
                                5
                            </cell>
                            <cell>
                                9
                            </cell>
                        </row>
                        <row>
                            <cell>
                                17
                            </cell>
                            <cell>
                                6
                            </cell>
                            <cell>
                                8
                            </cell>
                        </row>
                        <row>
                            <cell>
                                77
                            </cell>
                            <cell>
                                0
                            </cell>
                            <cell>
                                4
                            </cell>
                        </row>
                        <row>
                            <cell>
                                31
                            </cell>
                            <cell>
                                9
                            </cell>
                            <cell>
                                6
                            </cell>
                        </row>
                    
                
            </tabular></table>
            <p>We can also create hash functions for character-based items such as
                strings. The word <q>cat</q> can be thought of as a sequence of int
                values. The corresponding int value can be found by declaring an int and using
                it to store a char. You can also cast the value as an int using <term>int()</term></p>
            <pre>string h = "hello";
char c = h[0];
int i = c;

cout&lt;&lt;h&lt;&lt;endl;
cout&lt;&lt;c&lt;&lt;endl;
cout&lt;&lt;i&lt;&lt;endl;

&gt;&gt;hello
&gt;&gt;h
&gt;&gt;104</pre>
            <p>We can then take these three ordinal values, add them up, and use the
                remainder method to get a hash value (see <xref ref="fig-stringhash"/>).
                <xref ref="lst-hashfunction1"/> shows a function called <c>hash</c> that takes a
                string and a table size and returns the hash value in the range from 0
                to <c>tablesize</c>-1.</p>
            
            <figure align="center" xml:id="fig-stringhash">
                <caption>Hashing a String Using Ordinal Values</caption>
                    <image source="SearchHash/stringhash.png" width="80%">
                    <description>Diagram illustrating the process of hashing a string using ordinal values. Three characters 'c', 'a', and 't' are shown at the top with arrows pointing down to their respective ordinal values: '99', '97', and '116'. These values are summed to equal '312'. An arrow then points from this sum to an operation '312 % 11', which results in '4'. This demonstrates a simple hash function where the sum of the character ordinals is divided by 11 to get a remainder, which serves as the hash value.</description>
                    </image>
                </figure>
            
            <p xml:id="search-hash_lst-hashfunction1" names="lst_hashfunction1"><term>Listing 1</term></p>

    <program xml:id="simplehash" interactive="activecode" language="cpp">
        <input>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// uses ordinal values, of strings  and using positional values to weight them
//to generate A hash value
int hashfunc(string a, int tablesize) {
    int sum=0;
    for (unsigned int pos=0; pos&lt;a.length(); pos++) {
        sum += int(a[pos]); // getting ordinal values, and using positional values to weight them
        //adding them up, and using the remainder method to get a hash value.
    }

    return sum%tablesize;
}

int main() {
    cout&lt;&lt;hashfunc("First!" , 10)&lt;&lt;endl;
    cout&lt;&lt;hashfunc("Second!", 10)&lt;&lt;endl;
    cout&lt;&lt;hashfunc("Third!" , 10)&lt;&lt;endl;

    return 0;
}
        </input>
    </program>
            <p>It is interesting to note that when using this hash function, anagrams
                will always be given the same hash value. To remedy this, we could use
                the position of the character as a weight. <xref ref="fig-stringhash2"/> shows
                one possible way to use the positional value as a weighting factor. The
                modification to the <c>hash</c> function is left as an exercise.</p>
            
            <figure align="center" xml:id="fig-stringhash2">
                <caption>Hashing a String Using Ordinal Values with Weighting</caption>
                    <image source="SearchHash/stringhash2.png" width="80%">
                    <description>Image depicting a hashing algorithm that uses ordinal values of characters with weighting by their positions. The character 'c' in position 1 is multiplied by its ordinal value '99' and added to 1, 'a' in position 2 is multiplied by '97' and added to 2, and 't' in position 3 is multiplied by '116' and added to 3. The resulting sums are combined to total '641'. This sum is then divided by 11, as shown by the operation '641 % 11', resulting in a hash value of '3'.</description>
                    </image>
                </figure>

            <p>You may be able to think of a number of additional ways to compute hash
                values for items in a collection. The important thing to remember is
                that the hash function has to be efficient so that it does not become
                the dominant part of the storage and search process. If the hash
                function is too complex, then it becomes more work to compute the slot
                name than it would be to simply do a basic sequential or binary search
                as described earlier. This would quickly defeat the purpose of hashing.</p>
        </subsection>
        <subsection xml:id="search-hash_collision-resolution">
            <title>Collision Resolution</title>
            <p>We now return to the problem of collisions. When two items hash to the
                same slot, we must have a systematic method for placing the second item
                in the hash table. This process is called <term>collision resolution</term>. <idx>collision resolution</idx>As
                we stated earlier, if the hash function is perfect, collisions will
                never occur. However, since this is often not possible, collision
                resolution becomes a very important part of hashing.</p>
            
            
            <p>One method for resolving collisions looks into the hash table and tries
                to find another open slot to hold the item that caused the collision. A
                simple way to do this is to start at the original hash value position
                and then move in a sequential manner through the slots until we
                encounter the first slot that is empty. Note that we may need to go back
                to the first slot (circularly) to cover the entire hash table. This
                collision resolution process is referred to as <term>open addressing</term> in
                that it tries to find the next open slot or address in the hash table.<idx>open addressing</idx>
                By systematically visiting each slot one at a time, we are performing an
                open addressing technique called <term>linear probing</term>.<idx>linear probing</idx></p>
            <p><xref ref="fig-linearprobing"/> shows an extended set of integer items under the
                simple remainder method hash function (54,26,93,17,77,31,44,55,20).
                <xref ref="search-hash_search-hash_tbl-hashvalues1"/> above shows the hash values for the original items.
                <xref ref="fig-hashtable2"/> shows the original contents. When we attempt to
                place 44 into slot 0, a collision occurs. Under linear probing, we look
                sequentially, slot by slot, until we find an open position. In this
                case, we find slot 1.</p>
            <p>Again, 55 should go in slot 0 but must be placed in slot 2 since it is
                the next open position. The final value of 20 hashes to slot 9. Since
                slot 9 is full, we begin to do linear probing. We visit slots 10, 0, 1,
                and 2, and finally find an empty slot at position 3.</p>
            <figure align="center" xml:id="fig-linearprobing1">
                <caption>Collision Resolution with Linear Probing</caption>
                    <image source="SearchHash/linearprobing1.png" width="80%">
                    <description>Image of a hash table illustrating collision resolution with linear probing. The table has eleven slots numbered from 0 to 10. Filled slots contain the following integers: '77' in slot 0, '44' in slot 1, '55' in slot 2, '20' in slot 3, '26' in slot 4, '93' in slot 5, '17' in slot 6, '31' in slot 9, and '54' in slot 10. Slots 7 and 8 are labeled 'None', indicating they are empty. This setup suggests that when a collision occurs, the algorithm probes sequentially through the table to find the next available slot.</description>
                    </image>
                </figure>
            <p>Once we have built a hash table using open addressing and linear
                probing, it is essential that we utilize the same methods to search for
                items. Assume we want to look up the item 93. When we compute the hash
                value, we get 5. Looking in slot 5 reveals 93, and we can return
                <c>True</c>. What if we are looking for 20? Now the hash value is 9, and
                slot 9 is currently holding 31. We cannot simply return <c>False</c> since
                we know that there could have been collisions. We are now forced to do a
                sequential search, starting at position 10, looking until either we find
                the item 20 or we find an empty slot.</p>
            <p>A disadvantage to linear probing is the tendency for <term>clustering</term>;
                items become clustered in the table.<idx>clustering</idx> This means that if many collisions
                occur at the same hash value, a number of surrounding slots will be
                filled by the linear probing resolution. This will have an impact on
                other items that are being inserted, as we saw when we tried to add the
                item 20 above. A cluster of values hashing to 0 had to be skipped to
                finally find an open position. This cluster is shown in
                <xref ref="fig-clustering"/>.</p>

            <figure align="center" xml:id="fig-clustering">
                <caption>A Cluster of Items for Slot 0</caption>
                    <image source="SearchHash/clustering.png" width="80%">
                    <description>Image of a hash table with a series of filled and empty slots. The slots are numbered from 0 to 10. Slot 0 contains the number '77', followed by '44' in slot 1, '55' in slot 2, '20' in slot 3, '26' in slot 4, '93' in slot 5, and '17' in slot 6. Slots 7 and 8 are empty and labeled 'None'. Slot 9 contains the number '31', and slot 10 contains '54'. This demonstrates a clustering effect where a sequence of items are hashed to neighboring slots starting from slot 0.</description>
                    </image>
                </figure>

            <p>One way to deal with clustering is to extend the linear probing
                technique so that instead of looking sequentially for the next open
                slot, we skip slots, thereby more evenly distributing the items that
                have caused collisions. This will potentially reduce the clustering that
                occurs. <xref ref="fig-linearprobing2"/> shows the items when collision
                resolution is done with a <q>plus 3</q> probe. This means that once a
                collision occurs, we will look at every third slot until we find one
                that is empty.</p>
            <figure align="center" xml:id="fig-linearprobing2">
                <caption>Collision Resolution Using <q>Plus 3</q></caption>
                    <image source="SearchHash/linearprobing2.png" width="80%">
                    <description>Image of a hash table with eleven slots, demonstrating collision resolution using the 'Plus 3' strategy. The slots are numbered from 0 to 10, with '77' in slot 0, '55' in slot 1, 'None' in slot 2, '44' in slot 3, '26' in slot 4, '93' in slot 5, '17' in slot 6, '20' in slot 7, 'None' in slot 8, '31' in slot 9, and '54' in slot 10. The 'None' slots indicate empty positions where no value has been hashed to. The placement of numbers suggests that when a collision occurs, the item is placed in the next available slot that is three positions away.</description>
                    </image>
                </figure>
            <p> The general name for this process of looking for another slot after a
                collision is <term>rehashing</term>. <idx>rehashing</idx> With simple linear probing, the rehash
                function is <m>newhashvalue = rehash(oldhashvalue)</m> where
                <m>rehash(pos) = (pos + 1) \% sizeoftable</m>. The <q>plus 3</q> rehash
                can be defined as <m>rehash(pos) = (pos+3) \% sizeoftable</m>. In
                general, <m>rehash(pos) = (pos + skip) \% sizeoftable</m>. It is
                important to note that the size of the <q>skip</q> must be such that all the
                slots in the table will eventually be visited. Otherwise, part of the
                table will be unused. To ensure this, it is often suggested that the
                table size be a prime number. This is the reason we have been using 11
                in our examples.</p>
                <p>A variation of the linear probing idea is called <term>quadratic probing</term>.
                <idx>quadratic probing</idx> Instead of using a constant <q>skip</q> value, we use a rehash function that
                increments the hash value by 1, 3, 5, 7, 9, and so on. This means that
                if the first hash value is <em>h</em>, the successive values are <m>h+1</m>,
                <m>h+4</m>, <m>h+9</m>, <m>h+16</m>, and so on. In other words,
                quadratic probing uses a skip consisting of successive perfect squares.
                <xref ref="fig-quadratic"/> shows our example values after they are placed using
                this technique.</p> 

            <figure align="center" xml:id="fig-quadratic">
                <caption>Collision Resolution with Quadratic Probing</caption>
                    <image source="SearchHash/quadratic.png" width="80%">
                    <description>Image of a hash table with eleven numbered slots, illustrating collision resolution with quadratic probing. The hash table contains the numbers '77' in slot 0, '44' in slot 1, '20' in slot 2, '55' in slot 3, '26' in slot 4, '93' in slot 5, '17' in slot 6, and slots 7 and 8 are empty, labeled 'None'. The table ends with '31' in slot 9 and '54' in slot 10. The 'None' slots indicate that no items have been placed there, and the distribution of numbers shows that quadratic probing has been used to resolve collisions by placing items in slots that are a quadratic function of the distance from the original hashed slot.</description>
                    </image>
                </figure>
            <p>An alternative method for handling the collision problem is to allow
                each slot to hold a reference to a collection (or chain) of items.
                <term>Chaining</term> allows many items to exist at the same location in the hash
                table. When collisions happen, the item is still placed in the proper
                slot of the hash table.<idx>chaining</idx> As more and more items hash to the same
                location, the difficulty of searching for the item in the collection
                increases. <xref ref="fig-chaining"/> shows the items as they are added to a hash
                table that uses chaining to resolve collisions.</p>
                
            <figure align="center" xml:id="fig-chaining">
                <caption>Collision Resolution with Chaining</caption>
                    <image source="SearchHash/chaining.png" width="80%">
                    <description>Image of a hash table with eleven slots numbered from 0 to 10, demonstrating collision resolution with chaining. Each slot is either empty, labeled 'None', or contains a vertical list of numbers, representing a chain of items that have been hashed to the same slot. Slot 0 has a chain of '77', followed by '44' and '55'. Slot 4 has '26' and '93', slot 6 has '17', slot 9 has '31' and '54', and slot 10 has '20'. The chains are represented by numbers in boxes with arrows pointing downwards to the next number in the chain, depicting how collisions are resolved by linking items within the same slot.</description>
                    </image>
                </figure>
            <p>When we want to search for an item, we use the hash function to generate
                the slot where it should reside. Since each slot holds a collection, we
                use a searching technique to decide whether the item is present. The
                advantage is that on the average there are likely to be many fewer items
                in each slot, so the search is perhaps more efficient. We will look at
                the analysis for hashing at the end of this section.</p>
            
            
        </subsection>
        <subsection xml:id="search-hash_implementing-the-map-abstract-data-type">
            <title>Implementing the <c>Map</c> Abstract Data Type</title>
            <p>One of the most useful C++ data structures is the <term>map</term>. Recall that
                a map is an associative data type where you can store key&#8211;data
                pairs. <idx>map</idx> In a map data structure, the key plays a crucial role as it is used
                to look up and retrieve the associated data value. By providing a key, 
                you can quickly access the specific data element stored within the map.</p>
            <p>The map abstract data type is defined as follows. The structure is an
                unordered collection of associations between a key and a data value. The
                keys in a map are all unique so that there is a one-to-one relationship
                between a key and a value. The operations are given below.</p>
            
            <table xml:id="search-hash_id12"><tabular>
                <title><term>Table 1: Map  Operations</term></title>
                
                    
                    
                    
                        <row header="yes">
                            <cell>
                                <term>Map Operation</term>
                            </cell>
                            <cell>
                                <term>Description</term>
                            </cell>
                        </row>
                    
                    
                        <row>
                            <cell>
                                <c>m.Map()</c>
                            </cell>
                            <cell>
                                Create a new, empty map. It returns an empty
                                    map collection
                            </cell>
                        </row>
                        <row>
                            <cell>
                                <c>m.put(key,val)</c>
                            </cell>
                            <cell>
                                Add a new key-value pair to the map. If the
                                    key is already in the map then replace the
                                    old value with the new value
                            </cell>
                        </row>
                        <row>
                            <cell>
                                <c>m.get(key)</c>
                            </cell>
                            <cell>
                                Given a key, return the value stored in the
                                    map or <c>None</c> otherwise
                            </cell>
                        </row>
                        <row>
                            <cell>
                                <c>del m[key]</c>
                            </cell>
                            <cell>
                                Delete the key-value pair from the map
                            </cell>
                        </row>
                        <row>
                            <cell>
                                <c>len(m)</c>
                            </cell>
                            <cell>
                                Return the number of key-value pairs stored
                                    in the map
                            </cell>
                        </row>
                        <row>
                            <cell>
                                <c>in</c>
                            </cell>
                            <cell>
                                Return <c>True</c> for a statement of the form
                                    <c>key in map</c>, if the given is in the map
                                    and <c>False</c> otherwise
                            </cell>
                        </row>
                    
                
            </tabular></table>
            <p>One of the great benefits of a map is the fact that given a key,
                we can look up the associated data value very quickly. In order to
                provide this fast look up capability, we need an implementation that
                supports an efficient search. We could use a list with sequential or
                binary search but it would be even better to use a hash table as
                described above since looking up an item in a hash table can approach
                <m>O(1)</m> performance.</p>
            <p>In <xref ref="lst-hashtablecodeconstructor"/> we use two lists to create a
                <c>HashTable</c> class that implements the Map abstract data type. One
                list, called <c>slots</c>, will hold the key items and a parallel list,
                called <c>data</c>, will hold the data values. When we look up a key, the
                corresponding position in the data list will hold the associated data
                value. We will treat the key list as a hash table using the ideas
                presented earlier. Note that the initial size for the hash table has
                been chosen to be 11. Although this is arbitrary, it is important that
                the size be a prime number so that the collision resolution algorithm
                can be as efficient as possible.</p>
            
            <p xml:id="search-hash_lst-hashtablecodeconstructor" names="lst_hashtablecodeconstructor"><term>Listing 2</term></p>
            <pre>class HashTable{
    public:
    static const int size=11;
    int slots[size];
    string data[size];</pre>
            <p>In <xref ref="lst-hashtablecodestore"/>, <c>hashfunction</c> implements the
                simple remainder method. The collision resolution technique is linear probing
                with a <q>plus 1</q> rehash function. The <c>put</c> function assumes that there will
                eventually be an empty slot unless the key is already present in the <c>self.slots</c>.
                It computes the original hash value and if that slot is not empty, iterates the
                <c>rehash</c> function until an empty slot occurs. If a nonempty slot already
                contains the key, the old data value is replaced with the new data value.
                Dealing with the situation where there are no empty slots left is an exercise.</p>
            
            <p xml:id="search-hash_lst-hashtablecodestore" names="lst_hashtablecodestore"><term>Listing 3</term></p>
            <pre>def put(self,key,data):
    hashvalue = self.hashfunction(key,len(self.slots))

    if self.slots[hashvalue] == None:
        self.slots[hashvalue] = key
        self.data[hashvalue] = data
    else:
        if self.slots[hashvalue] == key:
            self.data[hashvalue] = data  #replace
        else:
            nextslot = self.rehash(hashvalue,len(self.slots))
            while self.slots[nextslot] != None and self.slots[nextslot] != key:
                nextslot = self.rehash(nextslot,len(self.slots))

        if self.slots[nextslot] == None:
            self.slots[nextslot] = key
            self.data[nextslot] = data
        else:
            self.data[nextslot] = data #replace

def hashfunction(self,key,size):
    return key%size

def rehash(self,oldhash,size):
    return (oldhash+1)%size</pre>
            <pre>int hashfunction(int key) {
    return key%size;
}

int rehash(int oldhash) {
    return (oldhash+1)%size;
}

void put(int key, string val){
    int hashvalue = hashfunction(key);
    int count = 0;

    if (data[hashvalue]=="") {
        slots[hashvalue] = key;
        data[hashvalue] = val;
    } else {
        if (slots[hashvalue] == key) {
            data[hashvalue] = val;
        } else {
            int nextslot = rehash(hashvalue);

            while (data[nextslot]!="" &amp;&amp; slots[nextslot] != key) {
                nextslot = rehash(nextslot);

                count++;
                if (count&gt;size) {
                    cout&lt;&lt;"TABLE FULL"&lt;&lt;endl;
                    return;
                }
            }
            if (data[nextslot]=="") {
                slots[nextslot]=key;
                data[nextslot]=val;
            } else {
                data[nextslot] = val;
            }
        }
    }
}</pre>
            <p>Likewise, the <c>get</c> function (see <xref ref="lst-hashtablecodesearch"/>)
                begins by computing the initial hash value. If the value is not in the
                initial slot, <c>rehash</c> is used to locate the next possible position.
                Notice that line 15 guarantees that the search will terminate by
                checking to make sure that we have not returned to the initial slot. If
                that happens, we have exhausted all possible slots and the item must not
                be present.</p>
            <p>The final methods of the <c>HashTable</c> class provide additional
                map functionality. We overload the __getitem__ and
                __setitem__ methods to allow access using``[]``. This means that
                once a <c>HashTable</c> has been created, the familiar index operator will
                be available. We leave the remaining methods as exercises.</p>
            
            <p xml:id="search-hash_lst-hashtablecodesearch" names="lst_hashtablecodesearch"><term>Listing 4</term></p>
            <pre>def get(self,key):
    startslot = self.hashfunction(key,len(self.slots))

    data = None
    stop = False
    found = False
    position = startslot
    while self.slots[position] != None and not found and not stop:
        if self.slots[position] == key:
            found = True
            data = self.data[position]
        else:
            position=self.rehash(position,len(self.slots))
            if position == startslot:
                stop = True
    return data

def __getitem__(self,key):
    return self.get(key)

def __setitem__(self,key,data):
    self.put(key,data)</pre>
            <pre>string get(int key) {
    int startslot = hashfunction(key);

    string val;
    bool stop=false;
    bool found=false;
    int position = startslot;
    while(data[position]!="" &amp;&amp; !found &amp;&amp; !stop) {
        if (slots[position]==key) {
            found = true;
            val = data[position];
        } else {
            position=rehash(position);
            if (position==startslot) {
                stop=true;
            }
        }

    }
    return val;
}</pre>
            <p>The following session shows the <c>HashTable</c> class in action. First we
                will create a hash table and store some items with integer keys and
                string data values.</p>
            <pre>int main() {
    HashTable h;

    h.put(54, "cat");
    h.put(26, "dog");
    h.put(93, "lion");
    h.put(17, "tiger");
    h.put(77, "bird");
    h.put(31, "cow");
    h.put(44, "goat");
    h.put(55, "pig");
    h.put(20, "chicken");
    cout&lt;&lt;h&lt;&lt;endl;

    return 0;
}

&gt;&gt; Output:
  77: bird
  44: goat
  55: pig
  20: chicken
  26: dog
  93: lion
  17: tiger
  0:
  0:
  31: cow
  54: cat</pre>
            <p>Next we will access and modify some items in the hash table. Note that
                the value for the key 20 is being replaced.</p>
            <pre>...
h.put(20,"chicken");
h.put(17,"tiger");
h.put(20,"duck");
cout&lt;&lt;h&lt;&lt;endl;
...

&gt;&gt; Output:
77: bird
44: goat
55: pig
20: duck
26: dog
93: lion
17: tiger
65535:
0:
31: cow
54: cat</pre>
            <p>The complete hash table example can be found in ActiveCode 1.</p>
            <TabNode tabname="C++" tabnode_options="{'subchapter': 'Hashing', 'chapter': 'SearchHash', 'basecourse': 'cppds', 'optional': '', 'optclass': '', 'tabname': 'C++'}">

    <program xml:id="complete_hash_cpp" interactive="activecode" language="cpp">
        <input>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class HashTable{
    public:
    static const int size=11; // initial size of hash table is prime to help with collision resolution
    int slots[size]; // list to hold key items
    string data[size]; // list to hold data values

    int hashfunction(int key) { // implements remainder method
        return key%size;
    }

      // Computes original hashvalue, and if slot is
      // not empty iterates until empty slot is found
    int rehash(int oldhash) {
        return (oldhash+1)%size;
    }

    // Function that assumes there will eventually be
    // an empty slot unless the key is alread present in the slot
    void put(int key, string val){
        int hashvalue = hashfunction(key);
        int count = 0;

        if (data[hashvalue]=="") {
            slots[hashvalue] = key;
            data[hashvalue] = val;
        } else {
            if (slots[hashvalue] == key) {
                data[hashvalue] = val;
            } else {
                int nextslot = rehash(hashvalue);

                while (data[nextslot]!="" &amp;&amp; slots[nextslot] != key) {
                    nextslot = rehash(nextslot);

                    count++;
                    if (count&gt;size) {
                        cout&lt;&lt;"TABLE FULL"&lt;&lt;endl;
                        return;
                    }
                }
                if (data[nextslot]=="") {
                    slots[nextslot]=key;
                    data[nextslot]=val;
                } else {
                    data[nextslot] = val;
                }
            }
        }
    }

    // computes the initial hash value
    // if value is not in the initial slot, uses
    // rehash to locate the next position
    string get(int key) {
        int startslot = hashfunction(key);

        string val;
        bool stop=false;
        bool found=false;
        int position = startslot;
        while(data[position]!="" &amp;&amp; !found &amp;&amp; !stop) {
            if (slots[position]==key) {
                found = true;
                val = data[position];
            } else {
                position=rehash(position);
                if (position==startslot) {
                    stop=true;
                }
            }

        }
        return val;
    }

    friend ostream&amp; operator&lt;&lt;(ostream&amp; stream, HashTable&amp; hash);
};



ostream&amp; operator&lt;&lt;(ostream&amp; stream, HashTable&amp; hash) {
    for (int i=0; i&lt;hash.size; i++) {
        stream&lt;&lt;hash.slots[i]&lt;&lt;": "&lt;&lt;hash.data[i]&lt;&lt;endl;
    }

    return stream;
}

int main() {
    HashTable h;

    h.put(54, "cat");
    h.put(26, "dog");
    h.put(93, "lion");
    h.put(17, "tiger");
    h.put(77, "bird");
    h.put(31, "cow");
    h.put(44, "goat");
    h.put(55, "pig");
    h.put(20, "chicken");
    cout&lt;&lt;h&lt;&lt;endl;

    h.put(20,"chicken");
    h.put(17,"tiger");
    h.put(20,"duck");
    cout&lt;&lt;h.get(20)&lt;&lt;endl;
    cout&lt;&lt;h.get(99)&lt;&lt;endl;

    return 0;
}
        </input>
    </program>
                </TabNode><TabNode tabname="Python" tabnode_options="{'subchapter': 'Hashing', 'chapter': 'SearchHash', 'basecourse': 'cppds', 'optional': '', 'optclass': '', 'tabname': 'Python'}">

    <program xml:id="complete_hash_py" interactive="activecode" language="python">
        <input>
class HashTable:
    def __init__(self):
        self.size = 11 # initial size of hash table is prime to help with collision resolution
        self.slots = [None] * self.size # list to hold key items
        self.data = [None] * self.size # list to hold data values

    def put(self,key,data):
      hashvalue = self.hashfunction(key,len(self.slots))

      if self.slots[hashvalue] == None:
        self.slots[hashvalue] = key
        self.data[hashvalue] = data
      else:
        if self.slots[hashvalue] == key:
          self.data[hashvalue] = data  #replace
        else:
          nextslot = self.rehash(hashvalue,len(self.slots))
          while self.slots[nextslot] != None and \
                          self.slots[nextslot] != key:
            nextslot = self.rehash(nextslot,len(self.slots))

          if self.slots[nextslot] == None:
            self.slots[nextslot]=key
            self.data[nextslot]=data
          else:
            self.data[nextslot] = data #replace

     # Function that assumes there will eventually be
     # an empty slot unless the key is alread present in the slot
    def hashfunction(self,key,size): # implements remainder method
         return key%size

     # Fomputes original hashvalue, and if slot is
     # not empty iterates until empty slot is found
    def rehash(self,oldhash,size):
        return (oldhash+1)%size

     # computes the initial hash value
     # if value is not in the initial slot, uses
     # rehash to locate the next position
    def get(self,key):
      startslot = self.hashfunction(key,len(self.slots))

      data = None
      stop = False
      found = False
      position = startslot
      while self.slots[position] != None and  \
                           not found and not stop:
         if self.slots[position] == key:
           found = True
           data = self.data[position]
         else:
           position=self.rehash(position,len(self.slots))
           if position == startslot:
               stop = True
      return data

    def __getitem__(self,key):
        return self.get(key)

    def __setitem__(self,key,data):
        self.put(key,data)

H=HashTable()
H[54]="cat"
H[26]="dog"
H[93]="lion"
H[17]="tiger"
H[77]="bird"
H[31]="cow"
H[44]="goat"
H[55]="pig"
H[20]="chicken"
print(H.slots)
print(H.data)

print(H[20])

print(H[17])
H[20]='duck'
print(H[20])
print(H[99])
        </input>
    </program>
                </TabNode>
        </subsection>
        <subsection xml:id="search-hash_analysis-of-hashing">
            <title>Analysis of Hashing</title>
            <p>We stated earlier that in the best case hashing would provide a
                <m>O(1)</m>, constant time search technique. However, due to
                collisions, the number of comparisons is typically not so simple. Even
                though a complete analysis of hashing is beyond the scope of this text,
                we can state some well-known results that approximate the number of
                comparisons necessary to search for an item.</p>
            <p>The most important piece of information we need to analyze the use of a
                hash table is the load factor, <m>\lambda</m>. Conceptually, if
                <m>\lambda</m> is small, then there is a lower chance of collisions,
                meaning that items are more likely to be in the slots where they belong.
                If <m>\lambda</m> is large, meaning that the table is filling up,
                then there are more and more collisions. This means that collision
                resolution is more difficult, requiring more comparisons to find an
                empty slot. With chaining, increased collisions means an increased
                number of items on each chain.</p>
            <p>As before, we will have a result for both a successful and an
                unsuccessful search. For a successful search using open addressing with
                linear probing, the average number of comparisons is approximately
                <m>\frac{1}{2}\left(1+\frac{1}{1-\lambda}\right)</m> and an
                unsuccessful search gives
                <m>\frac{1}{2}\left(1+\left(\frac{1}{1-\lambda}\right)^2\right)</m>
                If we are using chaining, the average number of comparisons is
                <m>1 + \frac {\lambda}{2}</m> for the successful case, and simply
                <m>\lambda</m> comparisons if the search is unsuccessful.</p>
                <reading-questions xml:id="rq-hashing-search">
                    <exercise label="HASH_1">
                        <statement>
                    
                                <p>In a hash table of size 13 which index positions would the following two keys map to?  27,  130</p>
                    
                        </statement>
                    <choices>
                    
                            <choice>
                                <statement>
                                    <p>1, 10</p>
                                </statement>
                                <feedback>
                                    <p>Be careful to use modulo not integer division</p>
                                </feedback>
                            </choice>
                    
                            <choice>
                                <statement>
                                    <p>13, 0</p>
                                </statement>
                                <feedback>
                                    <p>Don't divide by two, use the modulo operator.</p>
                                </feedback>
                            </choice>
                    
                            <choice correct="yes">
                                <statement>
                                    <p>1, 0</p>
                                </statement>
                                <feedback>
                                    <p>27 % 13 == 1 and 130 % 13 == 0</p>
                                </feedback>
                            </choice>
                    
                            <choice>
                                <statement>
                                    <p>2, 3</p>
                                </statement>
                                <feedback>
                                    <p>Use the modulo operator</p>
                                </feedback>
                            </choice>
                    </choices>
                    
                    </exercise>
                    
                    <exercise label="HASH_2">
                        <statement>
                    
                                <p>Suppose you are given the following set of keys to insert into a hash table that holds exactly 11 values:  113 , 117 , 97 , 100 , 114 , 108 , 121 , 105 , 99 Which of the following best demonstrates the contents of the hash table after all the keys have been inserted using linear probing?</p>
                    
                        </statement>
                    <choices>
                    
                            <choice>
                                <statement>
                                    <p>100, __, __, 113, 114, 105, 121, 117, 97, 108, 99</p>
                                </statement>
                                <feedback>
                                    <p>It looks like you may have been doing modulo 2 arithmentic.  You need to use the hash table size as the modulo value.</p>
                                </feedback>
                            </choice>
                    
                            <choice correct="yes">
                                <statement>
                                    <p>121, 100, 99, 113, 114, __, 105, 117, __, 97, 108</p>
                                </statement>
                                <feedback>
                                    <p>Using modulo 11 arithmetic and linear probing gives these values</p>
                                </feedback>
                            </choice>
                    
                            <choice>
                                <statement>
                                    <p>100, 113, 117, 97, 14, 108, 121, 105, 99, __, __</p>
                                </statement>
                                <feedback>
                                    <p>It looks like you are using modulo 10 arithmetic, use the table size.</p>
                                </feedback>
                            </choice>
                    
                            <choice>
                                <statement>
                                    <p>117, 114, 108, 121, 105, 99, __, __, 97, 100, 113</p>
                                </statement>
                                <feedback>
                                    <p>Be careful to use modulo not integer division.</p>
                                </feedback>
                            </choice>
                    </choices>
                    
                    </exercise>
                    </reading-questions>
        </subsection>
 
    </section>
    
