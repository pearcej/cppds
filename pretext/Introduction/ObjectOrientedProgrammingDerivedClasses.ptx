<?xml version="1.0" ?><section xml:id="introduction_inheritance-in-c">
        <title>Inheritance in C++</title>
        <introduction><p>In this section we introduce another important aspect of
            object-oriented programming. <term>Inheritance</term> is the ability for one
            class to be related to another class in much the same way that people
            can be related to one another. Children inherit characteristics from
            their parents. Similarly, C++ child classes can inherit
            characteristic data and/or behaviors from a parent class. The child classes are
            often referred to as <term>subclasses</term> or <term>derived classes</term>, and the parent
            class is often called the <term>base class</term> or <term>superclass</term>.</p>
        <p><xref ref="fig-inherit1"/> shows the built-in C++ collections and their
            relationships to one another. We call a relationship structure such as
            this an <term>inheritance hierarchy</term>. For example, the string is a child of
            the sequential collection. In this case, we call the string the child and
            the sequence the parent (or subclass string and superclass sequence). This
            is often referred to as an <c>IS-A Relationship</c> (the string <term>IS-A</term>
            sequential collection). This implies that strings inherit important
            characteristics from sequences, namely the ordering of the underlying
            data and operations such as concatenation, repetition, and indexing.</p>
        <figure align="center" xml:id="fig-inherit1">
                <caption>An Inheritance Hierarchy for C++ Collections</caption>
                    <image source="Introduction/inheritance1.png" width="70%">
                    <description><p>Hierarchy chart showing the classification of C++ containers. The top of the hierarchy is labeled 'C++ Containers', branching into 'Sequence Containers' on the left and 'Associative Containers' on the right. Under 'Sequence Containers', there are three sub-categories: 'Arrays', 'Vectors', and 'Strings'. 'Associative Containers' has a single sub-category labeled 'Unordered Maps'. The layout suggests an inheritance structure where sequence and associative containers are types of C++ containers.</p></description>
                    </image>
                </figure>

        <p>Vectors, arrays, and strings are all types of sequential collections. They
            all inherit common data organization and operations. However, each of
            them is distinct as well. The children all gain from their parents
            but distinguish themselves by adding additional characteristics.</p>
        <p>By organizing classes in this hierarchical fashion, object-oriented
            programming languages allow previously written code to be extended to
            meet the needs of a new situation. In addition, by organizing data in
            this hierarchical manner, we can better understand the relationships
            that exist. We can be more efficient in building our abstract
            representations.</p>
        <p>A child class inherits both behaviors and properties
            from the parent subject to some access restrictions.
            These variables and functions become members of the derived class.
            <idx>virtual function</idx><idx>virtual method</idx>A <term>virtual function</term> (also known as a <term>virtual method</term>) is a member function 
            that is declared within a base class and is designed to be overridden by a 
            derived class. 
            For this in C++, the keyword
            <c>virtual</c> is used.
            A simple example of using a virtual function in C++ is shown in <xref ref="virtualfunction"/>.
            In this example, the two derived subclasses inherit the <c>printType</c>
            method from the Base class.</p>

        <listing xml:id="virtualfunction">
            <caption>Virtual function example</caption>
            <program language="cpp" label="virtualfunction-prog"><code>
#include &lt;iostream&gt;
using namespace std;

class Base {
public:

        virtual void printType() { // Creates function called  printType
                subfunction();
                cout &lt;&lt; &quot;I'm inherited!&quot; &lt;&lt; endl &lt;&lt; endl;
        }

        virtual void subfunction(){
        // empty
        }
};

class SubFirst : public Base {
virtual void subfunction() {
        cout &lt;&lt; &quot;I'm one type of sub-class!&quot; &lt;&lt; endl;
}
};

class SubSecond : public Base {
virtual void subfunction() {
        cout &lt;&lt; &quot;I'm another type of sub class!&quot; &lt;&lt; endl;
}
};

int main() {
        SubFirst first;       // runs  subfirst class using printType virtual function
        first.printType();    // calls Subfirst class, and runs virtual function on it's own

        SubSecond second;    // runs  subsecond class using printType virtual function
        second.printType();  // calls Subsecond class, and runs virtual function on it's own

        return 0;
}
            </code></program>
        </listing>
</introduction>
        <subsection xml:id="introduction_logic-gates-and-circuits">
            <title>Logic Gates and Circuits</title>
            <p>To explore this idea further, we will construct a <term>simulation</term>, an
                application to simulate digital circuits. The basic building block for
                this simulation will be the logic gate. These electronic switches
                represent Boolean algebra relationships between their input and their
                output. In general, gates have a single output line. The value of the
                output is dependent on the values given on the input lines.</p>
            <p><term>AND</term> gates have two input lines, each of which can be either 0 or 1,
                representing <c>false</c> or <c>true</c>, respectively. If both of the input
                lines have the value 1, the resulting output is 1. However, if either or
                both of the input lines is 0, the result is 0. <term>OR</term> gates also have two
                input lines and produce a 1 if one or both of the input values is a 1.
                In the case where both input lines are 0, the result is 0.</p>
            <p><term>NOT</term> gates differ from the other two gates in that they only have a
                single input line. The output value is simply the opposite of the input
                value. If 0 appears on the input, 1 is produced on the output.
                Similarly, 1 produces 0. <xref ref="ooderive_fig-truthtable"/> shows how each of these
                gates is typically represented. Each gate also has a <term>truth table</term> of
                values showing the input-to-output mapping that is performed by the
                gate.</p>

            <figure align="center" xml:id="ooderive_fig-truthtable">
                <caption>Three Types of Logic Gates</caption>
                    <image source="Introduction/truthtable.png" width="50%">
                    <description><p>Image depicting three types of logic gates and their corresponding truth tables. On the left is the 'AND' gate symbol with a two-input truth table below it, showing outputs of '0' for all inputs except '1' and '1'. The center shows the 'OR' gate symbol with a truth table, displaying '1' when at least one input is '1'. On the right, the 'NOT' gate symbol is presented with a single-input truth table, showing an output inverse to the input.</p></description>
                    </image>
                </figure>
            <p>By combining these gates in various patterns and then applying a set of
                input values, we can build circuits that have logical functions.
                <xref ref="ooderive_fig-circuit1"/> shows a circuit consisting of two <term>AND</term> gates,
                one <term>OR</term> gate, and a <term>NOT</term> gate. The output lines from the two <term>AND</term> gates
                feed directly into the <term>OR</term> gate, and the resulting output from the <term>OR</term>
                gate is given to the <term>NOT</term> gate. If we apply a set of input values to the
                four input lines (two inputs for each <term>AND</term> gate), the values are processed and a
                result appears at the output of the <term>NOT</term> gate. <xref ref="ooderive_fig-circuit1"/> also
                shows an example with values.</p>

            <figure align="center" xml:id="ooderive_fig-circuit1">
                <caption>Circuit</caption>
                    <image source="Introduction/circuit1.png" width="50%">
                    <description><p>Diagram of a logic circuit with labeled gates and sample inputs/outputs. The top part shows two 'AND' gates labeled 'g1' and 'g2' feeding into an 'OR' gate labeled 'g3', which in turn feeds into a 'NOT' gate labeled 'g4'. Below, the same circuit is shown with binary inputs and the resulting outputs: 'AND' gates receiving '0, 1' and '1, 1' inputs with '0' and '1' outputs respectively; the 'OR' gate then combines the two to output '1', which is inverted to '0' by the 'NOT' gate.</p></description>
                    </image>
                </figure>




            <p>In order to implement a circuit such as <xref ref="ooderive_fig-circuit0"/>, we will first build a representation
                for logic gates. Logic gates are easily organized into a class
                inheritance hierarchy as shown in <xref ref="ooderive_fig-gates"/>. At the top of the
                hierarchy, the <c>LogicGate</c> class represents the most general
                characteristics of logic gates: namely, a label for the gate and an
                output line. The next level of subclasses breaks the logic gates into
                two families, those that have one input line and those that have two.
                Below that, the specific logic functions of each appear.</p>
            <figure align="center" xml:id="ooderive_fig-circuit0">
                <caption>Example Logic Circuit</caption>
                <image source="Introduction/logicquestion.png" width="50%">
                        <description><p>
                                Circuit diagram showing a two-input AND gate and a two-input OR gate.
                                The output of these two gates are the inputs to another two-input AND gate
                        </p></description>
                </image>
            </figure>

         
    
    <figure align="center" xml:id="ooderive_fig-gates">
        <caption>An Inheritance Hierarchy for Logic Gates</caption>
            <image source="Introduction/gates.png" width="50%">
            <description><p>Flowchart representing an inheritance hierarchy for logic gates. The topmost block is labeled 'Logic Gate', which branches down into two categories: 'Binary Gate' and 'Unary Gate'. Under 'Binary Gate', two further blocks represent 'AND' and 'OR' gates, each accompanied by their respective symbols. To the right, under 'Unary Gate', there's a block for the 'NOT' gate with its symbol. The structure implies that 'AND' and 'OR' gates inherit from 'Binary Gate', which along with 'Unary Gate' inherits from 'Logic Gate'.</p></description>
            </image>
        </figure>        

            <p>We can now start to implement the classes by starting with the most
                general, <c>LogicGate</c>. As noted earlier, each gate has a label for
                identification and a single output line. In addition, we need methods to
                allow a user of a gate to ask the gate for its label.</p>
            <p>The other behavior that every logic gate needs is the ability to know
                its output value. This will require that the gate perform the
                appropriate logic based on the current input. In order to produce
                output, the gate needs to know specifically what that logic is. This
                means calling a method to perform the logic computation. The complete
                class is shown in <xref ref="introduction_lst-logicgateclass"/>.</p>

        <exploration xml:id="introduction_expl-logicgateclass">
                <title>Complete <c>LogicGate</c> class</title>
                <task xml:id="introduction_lst-logicgateclass" label="introduction_lst-logicgateclass">
                        <title>C++ implementation</title>
                        <statement><program language="cpp" label="introduction_lst-logicgateclass-prog"><code>
class LogicGate {
public:
    LogicGate(string n) {
        label = n;
    }

    string getLabel() {
        return label;
    }

    bool getOutput() {
        output = performGateLogic();
        return output;
    }

    virtual bool performGateLogic() {
        cout &lt;&lt; "ERROR! performGateLogic BASE" &lt;&lt; endl;
        return false;
    }
protected:
    string label;
    bool output;
};
                </code></program></statement></task>
                <task xml:id="introduction_lst-logicgateclass-py" label="introduction_lst-logicgateclass-py">
                        <title>Python implementation</title>
                        <statement><program language="python" label="introduction_lst-logicgateclass-py-prog"><code>
class LogicGate:
        def __init__(self,n):
                self.label = n
                self.output = None

        def getLabel(self):
                return self.label

        def getOutput(self):
                self.output = self.performGateLogic()
                return self.output                        
                </code></program></statement></task>

        </exploration>

            <p>A protected member variable or function is similar to a
                private member but it has the additional benefit that they
                can be accessed by derived classes. The access keyword
                <c>protected</c> is used for this.</p>
            <p>We have also added a virtual function called <c>performGateLogic</c>.
                We do not yet know how each gate will perform
                its own logic operation; those details will be included by each
                gate class that is added to the hierarchy. This is a very powerful
                idea in object-oriented programming: we are providing a method that we
                require subclasses to override so that the behavior can be customized.
                The modifier <c>virtual</c> is a reference
                to the actual gate object invoking the method. Any new logic gate that
                gets added to the hierarchy will need to implement the
                <c>performGateLogic</c> function and it will be used at the appropriate
                time. Once done, the gate can provide its output value. This ability to
                extend a hierarchy that currently exists and provide the specific
                functions that the hierarchy needs to use the new class is extremely
                important for reusing existing code.</p>
            <p>We categorized the logic gates based on the number of input lines. The
                AND gate has two input lines. The OR gate also has two input lines. NOT
                gates have one input line. The <c>BinaryGate</c> class will be a subclass
                of <c>LogicGate</c> and will add two input lines. The <c>UnaryGate</c> class
                will also subclass <c>LogicGate</c> but will have only a single input line.
                In computer circuit design, these lines are sometimes called <q>pins</q> so
                we will use that terminology in our implementation.</p>

                <exploration xml:id="introduction_expl-binarygateclass">
                        <title>Implementation of <c>BinaryGate</c></title>
                        <task xml:id="introduction_lst-binarygateclass" label="introduction_lst-binarygateclass">
                                <title>C++ implementation</title>
                                <statement><program language="cpp" label="introduction_lst-binarygateclass-prog"><code>
class BinaryGate : public LogicGate {
public:
        BinaryGate(string n) : LogicGate(n) { // When we create an instance of
        // BinaryGate, data inherited from LogicGate are initialized with n;
                pinATaken = false;
                pinBTaken = false;
        }

        bool getPinA() {
                if (pinATaken==false) {
                        cout &lt;&lt; &quot;Enter Pin input for gate &quot; &lt;&lt; getLabel() &lt;&lt; &quot; : &quot;;
                        cin &gt;&gt; pinA;
                        pinATaken = true;
                }
                return pinA;
        }

        bool getPinB() {
                if (pinBTaken==false ) {
                        cout &lt;&lt; &quot;Enter Pin input for gate &quot; &lt;&lt; getLabel() &lt;&lt; &quot; : &quot;;
                        cin &gt;&gt; pinB;
                        pinBTaken = true;
                }
                return pinB;
        }

protected:
        bool pinA;
        bool pinATaken;
        bool pinB;
        bool pinBTaken;
};
                        </code></program></statement></task>
                        <task xml:id="introduction_lst-binarygateclass-py" label="introduction_lst-binarygateclass-py">
                                <title>Python implementation</title>
                                <statement><program language="python" label="introduction_lst-binarygateclass-py-prog"><code>
class BinaryGate(LogicGate):

        def __init__(self,n):
                LogicGate.__init__(self,n)

                self.pinA = None
                self.pinB = None

        def getPinA(self):
                return int(input(&quot;Enter Pin A input for gate &quot;+ self.getLabel()+&quot;-&gt;&quot;))

        def getPinB(self):
                return int(input(&quot;Enter Pin B input for gate &quot;+ self.getLabel()+&quot;-&gt;&quot;))
                                </code></program></statement>
                        </task>
                </exploration>

                <exploration xml:id="introduction_expl-unarygateclass">
                        <title>Implementation of <c>UnaryGate</c></title>
                        <task xml:id="introduction_lst-unarygateclass" label="introduction_lst-unarygateclass">
                                <title>C++ implementation</title>
                                <statement><program language="cpp" label="introduction_lst-unarygateclass-prog"><code>
class UnaryGate : public LogicGate {
public:
        UnaryGate(string n) : LogicGate(n) {
                pinTaken = false;
        }
        bool getPin() {
                if (pinTaken==false) {
                        cout &lt;&lt; &quot;Enter Pin input for gate &quot; &lt;&lt; getLabel() &lt;&lt; &quot;: &quot;;
                        cin &gt;&gt; pin;
                        pinTaken = true;
                }
                return pin;
        }
protected:
        bool pin;
        bool pinTaken;
};
                        </code></program></statement></task>
                        <task xml:id="introduction_lst-unarygateclass-py" label="introduction_lst-unarygateclass-py">
                                <title>Python implementation</title>
                                <statement><program language="python" label="introduction_lst-unarygateclass-py-prog"><code>
class UnaryGate(LogicGate):

        def __init__(self,n):
                LogicGate.__init__(self,n)

                self.pin = None

        def getPin(self):
                return int(input(&quot;Enter Pin input for gate &quot;+ self.getLabel()+&quot;-&gt;&quot;))
                </code></program></statement></task></exploration>

            <p><xref ref="introduction_lst-binarygateclass"/> and <xref ref="introduction_lst-unarygateclass"/> implement these two
                classes. The constructors in both of these classes start with an
                explicit call to the constructor of the parent class using the parent's name
                method. When creating an instance of the <c>BinaryGate</c> class, we
                first want to initialize any data items that are inherited from
                <c>LogicGate</c>. In this case, that means the label for the gate. The
                constructor then goes on to add the two input lines (<c>pinA</c> and
                <c>pinB</c>). This is a very common pattern that you should always use when
                building class hierarchies. Child class constructors need to call parent
                class constructors and then move on to their own distinguishing data.</p>
            <p>The only behavior that the <c>BinaryGate</c> class adds is the ability to
                get the values from the two input lines. Since these values come from
                some external place, we will simply ask the user via an input statement
                to provide them. The same implementation occurs for the <c>UnaryGate</c>
                class except that there is only one input line.</p>
            <p>Now that we have a general class for gates depending on the number of
                input lines, we can build specific gates that have unique behavior. For
                example, the <c>AndGate</c> class will be a subclass of <c>BinaryGate</c>
                since AND gates have two input lines. As before, the first line of the
                constructor calls upon the parent class constructor (<c>BinaryGate</c>),
                which in turn calls its parent class constructor (<c>LogicGate</c>). Note
                that the <c>AndGate</c> class does not provide any new data since it
                inherits two input lines, one output line, and a label.</p>
            <p>The only thing <c>AndGate</c> needs to add is the specific behavior that
                performs the Boolean operation that was described earlier. This is the
                place where we can provide the <c>performGateLogic</c> method. For an <term>AND</term>
                gate, this method first must get the two input values and then only
                return 1 if both input values are 1. The complete class is shown in
                <xref ref="introduction_lst-andgateclass"/>.</p>
        
        <exploration xml:id="introduction_expl-andgateclass">
                <title>Implementation of <c>AndGate</c></title>
                <task xml:id="introduction_lst-andgateclass" label="introduction_lst-andgateclass">
                        <title>C++ implementation</title>
                        <statement><program language="cpp" label="introduction_lst-andgateclass-prog"><code>
class AndGate : public BinaryGate {
public:
        AndGate(string n) : BinaryGate(n) {};

        virtual bool performGateLogic() {
                bool a = getPinA();
                bool b = getPinB();
                if (a == 1 &amp;&amp; b == 1) {
                        return true;
                }
                else {
                        return false;
                }
        }
};
                </code></program></statement></task>
                <task xml:id="introduction_lst-andgateclass-py" label="introduction_lst-andgateclass-py">
                        <title>Python implementation</title>
                        <statement><program language="python" label="introduction_lst-andgateclass-py-prog"><code>
class AndGate(BinaryGate):

        def __init__(self,n):
                super(AndGate,self).__init__(n)

        def performGateLogic(self):

                a = self.getPinA()
                b = self.getPinB()
                if a==1 and b==1:
                        return 1
                else:
                        return 0
        </code></program></statement></task></exploration>

            <p>We can show the <c>AndGate</c> class in action by creating an instance and
                asking it to compute its output. The following session shows an
                <c>AndGate</c> object, <c>gand1</c>, that has an internal label <c>&quot;gand1&quot;</c>. When we
                invoke the <c>getOutput</c> method, the object must first call its
                <c>performGateLogic</c> method which in turn queries the two input lines.
                Once the values are provided, the correct output is shown.</p>

        <listing xml:id="introduction_fig-andusage">
            <caption><c>AndGate</c> Usage</caption>
            <program label="introduction_fig-andusage-prog"><code>
                &gt;&gt;&gt; AndGate gand2(&quot;gand2&quot;)
                &gt;&gt;&gt; gand2.getOutput()
                Enter Pin A input for gate gand2: 1
                Enter Pin B input for gate gand2: 1
                1
                &gt;&gt;&gt; gand2.getOutput()
                Enter Pin A input for gate gand2: 0
                Enter Pin B input for gate gand2: 0
                0
            </code></program>
        </listing>
.
           <p>The same development can be done for <term>OR</term> gates and <term>NOT</term> gates. The
                <c>OrGate</c> class will also be a subclass of <c>BinaryGate</c> and the
                <c>NotGate</c> class will extend the <c>UnaryGate</c> class. Both of these
                classes will need to provide their own <c>performGateLogic</c> functions,
                as this is their specific behavior.</p>
            <p>We can use a single gate by first constructing an instance of one of the
                gate classes and then asking the gate for its output (which will in turn
                need inputs to be provided). For example:</p>

            <listing xml:id="introduction_fig-ornotusage">
                <caption>Usage of <c>OrGate</c> and <c>NotGate</c></caption>
                <program label="introduction_fig-ornotusage-prog"><code>
&gt;&gt;&gt; g2 = OrGate(&quot;G2&quot;)
&gt;&gt;&gt; g2.getOutput()
Enter Pin A input for gate G2-&gt;1
Enter Pin B input for gate G2-&gt;1
1
&gt;&gt;&gt; g2.getOutput()
Enter Pin A input for gate G2-&gt;0
Enter Pin B input for gate G2-&gt;0
0
&gt;&gt;&gt; g3 = NotGate(&quot;G3&quot;)
&gt;&gt;&gt; g3.getOutput()
Enter Pin input for gate G3-&gt;0
1
                </code></program>
            </listing>
        </subsection>
        <subsection xml:id="introduction_building-circuits">
            <title>Building Circuits</title>
            <p>Now that we have the basic gates working, we can turn our attention to
                building circuits. In order to create a circuit, we need to connect
                gates together, the output of one flowing into the input of another. To
                do this, we will implement a new class called <c>Connector</c>.</p>
            <p>The <c>Connector</c> class will not reside in the gate hierarchy. It will,
                however, use the gate hierarchy in that each connector will have two
                gates, one on either end (see <xref ref="ooderive_fig-connector"/>).
                This relationship is
                very important in object-oriented programming. It is called the <term>HAS-A
                    Relationship</term>. Recall earlier that we used the phrase <q>IS-A
                Relationship</q> to say that a child class is related to a parent class,
                for example <c>UnaryGate</c> IS-A <c>LogicGate</c>.</p>
        <figure align="center" xml:id="ooderive_fig-connector">
                <caption>A Connector Connects the Output of One Gate to the Input of Another</caption>
                <image source="Introduction/connector.png" width="50%">
                <description><p>Diagram showing two logic gate symbols, 'AND' and 'OR', connected by a line labeled 'connector'. The 'AND' gate is on the left with an arrow pointing from its output to the 'connector'. Another arrow extends from the 'connector' to the input of the 'OR' gate on the right. This illustrates how the output of one gate serves as the input to another.</p></description>
                </image>
        </figure>


            <p>Now, with the <c>Connector</c> class, we say that a <c>Connector</c> HAS-A
                <c>LogicGate</c> meaning that connectors will have instances of the
                <c>LogicGate</c> class within them but are not part of the hierarchy. When
                designing classes, it is very important to distinguish between those
                that have the IS-A relationship (which requires inheritance) and those
                that have HAS-A relationships (with no inheritance).</p>
            <p><xref ref="ooderive_program"/> adds the <c>Connector</c> class.
                The two gate instances within each connector object are referred to as the
                <c>fromgate</c> and the <c>togate</c>, recognizing that data values will
                <q>flow</q> from the output of one gate into an input line of the next. The
                call to <c>setNextPin</c> is very important for making connections.
                We need to add this method to our gate classes so
                that each <c>togate</c> can choose the proper input line for the
                connection.</p>
      
            <figure align="center" xml:id="ooderive_fig-desired-circuit">
                <caption>Circit of NOT(AND(ganda,gnadb)OR AND(gandc,gandd))</caption>
                    <image source="Introduction/desired_circuit.png" width="80%">
                    <description><p>Circuit diagram illustrating a logical expression with labeled components. Two 'AND' gates, labeled 'gand1' and 'gand2', are connected to an 'OR' gate labeled 'gor3' via lines labeled 'connector'. The output of 'gor3' is then fed into a 'NOT' gate labeled 'gnot4'. The connections suggest the logical operation NOT(AND(a,b)) OR AND(c,d).</p></description>
                    </image>
                </figure>

            <listing xml:id="ooderive_program">
                <caption>Using the <c>Connector</c> Class</caption>
                <program interactive="activecode" language="cpp" label="ooderive_program-prog"><code>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// creates a class with a logic gate that returns the label, and boolean value
class LogicGate {
    public:
            LogicGate(string n){
                    label = n;
            }
            string getLabel(){
                    return label;
            }
            bool getOutput(){
                    output = performGateLogic();
                    return output;
            }
            virtual bool performGateLogic(){
                    cout &lt;&lt; &quot;ERROR! performGateLogic BASE&quot; &lt;&lt; endl;
                    return false;
            }

            virtual void setNextPin(bool source) {
                    cout &lt;&lt; &quot;ERROR! setNextPin BASE&quot; &lt;&lt; endl;
            }
    private:
            string label;
            bool output;
};

    //class that allows for the gates to have two inputs
class BinaryGate : public LogicGate {
    public:
            BinaryGate(string n) : LogicGate(n) {
                    pinATaken = false;
                    pinBTaken = false;
            }
            bool getPinA() {
                    if (pinATaken == false) {
                            cout &lt;&lt; &quot;Enter Pin A input for gate &quot; &lt;&lt; getLabel() &lt;&lt; &quot;: &quot;;
                            cin &gt;&gt; pinA;
                            pinATaken = true;
                    }
                    return pinA;
            }
            bool getPinB() {
                    if (pinBTaken == false) {
                            cout &lt;&lt; &quot;Enter Pin B input for gate &quot; &lt;&lt; getLabel() &lt;&lt; &quot;: &quot;;
                            cin &gt;&gt; pinB;
                            pinBTaken = true;
                    }
                    return pinB;
            }
            virtual void setNextPin(bool source) {
                    if (pinATaken == false) {
                            pinA = source;
                            this-&gt;pinATaken = true;
                    }
                    else if (pinBTaken == false) {
                            pinB = source;
                            this-&gt;pinBTaken = true;
                    }
            }
    private:
            bool pinA, pinATaken, pinB, pinBTaken;
};

    //allows for the creation of a logic gate with  one input
class UnaryGate : public LogicGate {
    public:
            UnaryGate(string n) : LogicGate(n) {
                    pinTaken = false;
            }
            bool getPin() {
                    if (pinTaken == false) {
                            cout &lt;&lt; &quot;Enter Pin input for gate &quot; &lt;&lt; getLabel() &lt;&lt; &quot;: &quot;;
                            cin &gt;&gt; pin;
                            pinTaken = true;
                    }
                    return pin;
            }
            virtual void setNextPin(bool source) {
                    if (pinTaken == false) {
                            pin = source;
                            pinTaken = true;
                    }
                    else {
                            return;
                    }
            }
    private:
            bool pin, pinTaken;
};

//Class that sets up the logic for an &quot;and&quot; gate
class AndGate : public BinaryGate{
    public:
            AndGate(string n) : BinaryGate(n) {};

            virtual bool performGateLogic(){
                    bool a = getPinA();
                    bool b = getPinB();
                    if (a == 1 &amp;&amp; b == 1) {
                            return true;
                    }
                    else {
                            return false;
                    }
            }
};

//class that sets up the logic for an &quot;or&quot; gate
class OrGate : public BinaryGate {
    public:
            OrGate(string n) : BinaryGate(n) {};

            virtual bool performGateLogic() {
                    bool a = getPinA();
                    bool b = getPinB();
                    if (a == 1 || b == 1) {
                            return true;
                    }
                    else {
                            return false;
                    }
            }
};

//class that sets up the logic for a &quot;not&quot; gate
class NotGate : public UnaryGate {
    public:
            NotGate(string n) : UnaryGate(n) {};

            virtual bool performGateLogic() {
                    if (getPin()) {
                            return false;
                    }
                    else {
                            return true;
                    }
            }
};

// class that sets up logic for the connection of one gate to another
class Connector{
    public:
            Connector(LogicGate *fgate, LogicGate *tgate) {
                    fromgate = fgate;
                    togate = tgate;
                    tgate-&gt;setNextPin(fromgate-&gt;getOutput());
            }
            LogicGate *getFrom() {
                    return fromgate;
            }
            LogicGate *getTo() {
                    return togate;
            }
    private:
            LogicGate *fromgate, *togate;
};

int main() {

    char stopme;

    //Setting labels
    AndGate gand1(&quot; AND1 &quot;);
    AndGate gand2(&quot; AND2 &quot;);
    OrGate  gor3(&quot; OR &quot;);
    NotGate gnot4(&quot; NOT &quot;);

    // The inputs can be changed here!
    gand1.setNextPin(0);
    gand1.setNextPin(0);
    gand2.setNextPin(0);
    gand2.setNextPin(0);

    //making comnnections
    Connector c1(&amp;gand1, &amp;gor3);
    Connector c2(&amp;gand2, &amp;gor3);
    Connector c3(&amp;gor3, &amp;gnot4);

    // The output shows order of operators
    cout &lt;&lt; gnot4.getLabel() &lt;&lt; &quot;(&quot;;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; gand1.getPinA() &lt;&lt; gand1.getLabel() &lt;&lt; gand1.getPinB() &lt;&lt; &quot;)&quot;;
    cout &lt;&lt; gor3.getLabel();
    cout &lt;&lt; &quot;(&quot; &lt;&lt; gand2.getPinA() &lt;&lt; gand2.getLabel() &lt;&lt; gand2.getPinB() &lt;&lt; &quot;)&quot;;
    cout &lt;&lt; &quot;) results in &quot; &lt;&lt; gnot4.getOutput() &lt;&lt; endl;

    cin &gt;&gt; stopme; //holds open window under some conditions.
    return 0;
}
                </code></program>
            </listing>

    <reading-questions xml:id="rq-oop-derived-classes">
        <title>Reading Questions</title>
        <exercise label="logic-gate-1">
                <statement>
        <p>What will the logic gate yield (1 / 0)? <var/>  </p></statement><setup><var><condition number="[0]"><feedback><p>Correct!</p></feedback></condition><condition number="[1]"><feedback><p>Take a closer look at the logic gates.</p></feedback></condition></var></setup></exercise>   
        <exercise label="mc_IS-A_HAS-A">
                <statement>
        
                    <p>What is the difference between HAS-A and IS-A relationships? Select all that apply.</p>
        
                </statement>
        <choices>
        
                    <choice correct="yes">
                        <statement>
                            <p>An IS-A class object is an instance of an inherited class.</p>
                        </statement>
                        <feedback>
                            <p>Correct!</p>
                        </feedback>
                    </choice>
        
                    <choice>
                        <statement>
                            <p>A HAS-A class object has all of the methods of another class.</p>
                        </statement>
                        <feedback>
                            <p>No. HAS-A relationships do not mean that one class is copying another class.</p>
                        </feedback>
                    </choice>
        
                    <choice>
                        <statement>
                            <p>An IS-A class object contains instances of another class.</p>
                        </statement>
                        <feedback>
                            <p>No. IS-A relationships do not mean that an object contains different class instances.</p>
                        </feedback>
                    </choice>
        
                    <choice>
                        <statement>
                            <p>A HAS-A class object is an instance of an inherited class.</p>
                        </statement>
                        <feedback>
                            <p>No, HAS-A reltionships do not use inheritance.</p>
                        </feedback>
                    </choice>
        
                    <choice correct="yes">
                        <statement>
                            <p>A HAS-A class object contains instances of another class.</p>
                        </statement>
                        <feedback>
                            <p>Correct!</p>
                        </feedback>
                    </choice>
        </choices>
        
            </exercise>

 <exercise label="OOPclassquestion">
 
        <statement>

            <!--OOP class example:-->
            <p><term>Question example</term></p>
            <program language="cpp" label="ObjectOrientedProgrammingDerivedClasses-prog"><code>
#include&lt;iostream&gt;
using namespace std;

class Vehicle
{

    protected:
        int wheels;
        int windows;
        int engine;
};

class Airplane: public Vehicle
{
    protected:
        // wheels
        // windows
        // engine
        int wings;
};
</code></program>
            <p>Which OOP principle is the above code an example of?</p>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>Encapsulation</p>
                </statement>
                <feedback>
                    <p>Encapsulation is the principle of hiding the contents of a class except when absolutely necessary. Wings is not hidden from Vehicle, it simply does not exist in the Vehicle class.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>Polymorphism</p>
                </statement>
                <feedback>
                    <p>Polymorphism is the ability to process objects or methods differently depending on their data type, class, number of arguments, etc. A subclass using parts of a pre-existing class is not an example of polymorphism because they are used in the same way.</p>
                </feedback>
            </choice>

                <choice correct="yes">
                <statement>
                    <p>Inheritance</p>
                </statement>
                <feedback>
                    <p>Correct! Airplane inherits many things from Vehicle</p>
                </feedback>
            </choice>
            <choice>
                <statement>
                    <p>Abstraction</p>
                </statement>
                <feedback>
                    <p>Abstraction is the principle of focusing on desired behaviors and properties while disregarding what is irrelevant/unimportant. Take another look at what the two classes have in common.</p>
                </feedback>
            </choice>
</choices>

    </exercise>
            <note>
                <title>Self  Check Challenge</title>
                <p>One of the fundamental building blocks of a computer is something called a flip flop.  It's not something that computer science professors wear on their feet, but rather a kind of circuit that is stable and stores the last piece of data that was put on it.  A simple flip-flop can be made from two <term>NOR</term> gates (a combination <term>OR</term> and <term>NOT</term>) that are tied together as in the following diagram. Create a new gate class, called NorGate. NorGates work like OrGates that have a Not attached to the output. See if you can use your new class to implement this.</p>
                <image source="Introduction/flipflop.png" width="50%"> 
                <description>
                <p>
                Image showing a simple flip-flop circuit constructed with two NOR gates. The circuit consists of two inputs labeled &quot;Reset&quot; and &quot;Set,&quot; 
                which feed into the respective NOR gates. The output of the upper NOR gate loops back as an input to the lower NOR gate, while the output 
                of the lower NOR gate loops back as an input to the upper NOR gate. This feedback loop creates a stable circuit that can store a single bit 
                of data based on the states of the &quot;Reset&quot; and &quot;Set&quot; inputs.
                </p>
                </description>
                </image>
                <p>Note if the initial inputs to Reset and Set are both 0 then the output of the flip-flop is 0.  But if the Set input is toggled to 1 then the output becomes 1.  The great thing is that when the set input goes to 0 the output stays 1, until the reset input is toggled to 1 which resets the output of the circuit back to zero.</p>
            </note>

        </reading-questions>
        </subsection>
        <conclusion><p>
            <!-- extra space before the progress bar -->   
        </p></conclusion>
    </section>
