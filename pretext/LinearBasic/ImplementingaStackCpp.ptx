<section xml:id="linear-basic_using-a-stack-in-c">
        <title>Using a Stack in C++</title>
        <p>Now that we have clearly defined the stack as an abstract data type we
            will turn our attention to using a stack with the help of the Standard Template Library (STL) in C++. Recall
            that when we give an abstract data type a physical implementation we
            refer to the implementation as a data structure.</p>
        <p>As we described in Chapter 1, in C++, as in any object-oriented
            programming language, the implementation of choice for an abstract data
            type such as a stack is the creation of a new class. The stack
            operations are implemented as methods. However, the STL already has a well
            written implementation of the Stack class.</p>
        <p>The following stack implementation (<xref ref="lst-stackcode1"/>) assumes that
            the end of the array will hold the top element of the stack. As the stack
            grows (as <c>push</c> operations occur), new items will be added on the end
            of the array. <c>pop</c> operations will manipulate that same end.</p>
        
        <TabNode tabname="C++" tabnode_options="{'subchapter': 'ImplementingaStackCpp', 'chapter': 'LinearBasic', 'basecourse': 'cppds', 'optional': '', 'optclass': '', 'tabname': 'C++'}">

    <program xml:id="stack_1ac_cpp" interactive="activecode" language="cpp">
        <input>
//Tests the push, empty, size, pop, and top methods of the stack library.

#include &lt;iostream&gt;
#include &lt;stack&gt;    // Calling Stack from the STL

using namespace std;

int main() {
    stack&lt;int&gt; newStack;

    newStack.push(3); //Adds 3 to the stack
    newStack.push(8);
    newStack.push(15);

    // returns a boolean response depending on if the stack is empty or not
    cout &lt;&lt; "Stack Empty? " &lt;&lt; newStack.empty() &lt;&lt; endl;

    // returns the size of the stack itself
    cout &lt;&lt; "Stack Size: " &lt;&lt; newStack.size() &lt;&lt; endl;

    // returns the topmost element of the stack
    cout &lt;&lt; "Top Element of the Stack: " &lt;&lt; newStack.top() &lt;&lt; endl;

    // removes the topmost element of the stack
    newStack.pop();

    cout &lt;&lt; "Top Element of the Stack: " &lt;&lt; newStack.top() &lt;&lt; endl;

    cout &lt;&lt; "Stack Size: " &lt;&lt; newStack.size() &lt;&lt; endl;

    return 0;
}
        </input>
    </program>
            </TabNode><TabNode tabname="Python" tabnode_options="{'subchapter': 'ImplementingaStackCpp', 'chapter': 'LinearBasic', 'basecourse': 'cppds', 'optional': '', 'optclass': '', 'tabname': 'Python'}">

    <program xml:id="stack_1ac_py" interactive="activecode" language="python">
        <input>
#Tests the push, empty, size, pop, and top methods of the stack library.

class Stack:
    def __init__(self): #initializes new stack instance
        self.items = []

    def isEmpty(self): #returns boolean
        return self.items == []

    def push(self, item): #pushes new item onto stack
        self.items.append(item)

    def pop(self): #removes topmost item from stack
        return self.items.pop()

    def top(self): #returns the topmost item from the stack
        return self.items[len(self.items)-1]

    def size(self): #returns the size of the stack
        return len(self.items)

def main():
    newStack = Stack()
    newStack.push(4)
    newStack.push(8)
    newStack.push(15)

    print("Stack Empty? ", newStack.isEmpty())

    print("Stack Size: ", newStack.size())

    print("Top Element of the Stack: ", newStack.top())

    newStack.pop();

    print("Top Element of the Stack: ", newStack.top())
main()
        </input>
    </program>
            </TabNode>

<reading-questions xml:id="rq-stack-implementation">
                <title>Reading Questions</title>
    <exercise label="stack_1">
        <statement>

            <p>Given the following sequence of stack operations, what is the top item on the stack when the sequence is complete?</p>
            <program language="cpp"><input>
stack&lt;int&gt; m;
m.push(5);
m.push(12);
m.pop();
m.push(27);
cout &lt;&lt; m.top();
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>5</p>
                </statement>
                <feedback>
                    <p>Remember that a stack is built from the bottom up.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>12</p>
                </statement>
                <feedback>
                    <p>pay attention to the line that says m.pop();.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>27</p>
                </statement>
                <feedback>
                    <p>Good job. This is correct because the 12 was poped of from the end and the 27 was pushed.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>The stack is empty</p>
                </statement>
                <feedback>
                    <p>This would mean everyting is removed from the stack, when does that happen?</p>
                </feedback>
            </choice>
</choices>

    </exercise>

    <exercise label="stack_2">
        <statement>

            <p>Given the following sequence of stack operations, what is the top item on the stack when the sequence is complete?</p>
            <program language="cpp"><input>
stack&lt;int&gt; m;
m.push(37);
m.push(56);
m.push(4);
while (!m.empty()){
    m.pop();
    m.pop();
}
</input></program>

        </statement>
<choices>

            <choice>
                <statement>
                    <p>37</p>
                </statement>
                <feedback>
                    <p>You may want to check out the docs for</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>the stack is empty</p>
                </statement>
                <feedback>
                    <p>There is an odd number of things on the stack but each time through the loop 2 things are popped.</p>
                </feedback>
            </choice>

            <choice correct="yes">
                <statement>
                    <p>an error will occur</p>
                </statement>
                <feedback>
                    <p>Good Job, this is true because the stack can not evenly pop off every item within itself, because there is an odd number of items.</p>
                </feedback>
            </choice>

            <choice>
                <statement>
                    <p>4</p>
                </statement>
                <feedback>
                    <p>You may want to check out the docs for isEmpty</p>
                </feedback>
            </choice>
</choices>

    </exercise>
</reading-questions>  
<p>
            
</p>
    </section>

