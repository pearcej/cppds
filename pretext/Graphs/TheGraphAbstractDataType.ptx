<section xml:id="graphs_the-graph-abstract-data-type">
        <title>The Graph Abstract Data Type</title>
        <p>The graph abstract data type (ADT) is defined as follows:</p>
        <p><ul>
            <li>
                <p><c>Graph()</c> creates a new, empty graph.</p>
            </li>
            <li>
                <p><c>addVertex(vert)</c> adds an instance of <c>Vertex</c> to the graph.</p>
            </li>
            <li>
                <p><c>addEdge(fromVert, toVert)</c> Adds a new, directed edge to the graph
                    that connects two vertices.</p>
            </li>
            <li>
                <p><c>addEdge(fromVert, toVert, weight)</c> Adds a new, weighted, directed
                    edge to the graph that connects two vertices.</p>
            </li>
            <li>
                <p><c>getVertex(vertKey)</c> finds the vertex in the graph named
                    <c>vertKey</c>.</p>
            </li>
            <li>
                <p><c>getVertices()</c> returns the list of all vertices in the graph.</p>
            </li>
            <li>
                <p><c>in</c> returns <c>True</c> for a statement of the form
                    <c>vertex in graph</c>, if the given vertex is in the graph, <c>False</c>
                    otherwise.</p>
            </li>
        </ul></p>
        <p>Beginning with the formal definition for a graph there are several ways
            we can implement the graph ADT in Python. We will see that there are
            trade-offs in using different representations to implement the ADT
            described above. There are two well-known implementations of a graph,
            the <idx>adjacency matrix</idx><term>adjacency matrix</term> and the <idx>adjacency list</idx><term>adjacency list</term>. We will explain
            both of these options, and then implement one as a Python class.</p>
<reading-questions xml:id="rq-graph-adt">
    <title>
Reading Question
    </title>

<exercise label="gadt">
    <statement><p>Drag and drop each graph abstract data type to its corresponding definition.</p></statement>
    <feedback><p>This is feedback.</p></feedback>
    <cardsort>
        <match>
            <premise order="1">Graph()</premise>
            <response>creates a new, empty graph.</response>
        </match>
        <match>
            <premise order="2">addVertex(vert)</premise>
            <response>adds an instance of Vertex to the graph.</response>
        </match>
        <match>
            <premise order="3">addEdge(fromVert, toVert)</premise>
            <response>Adds a new, directed edge to the graph that connects two vertices.</response>
        </match>
    </cardsort>
</exercise>

<exercise label="gadt1">
    <statement><p>Drag and drop each graph abstract data type to its corresponding definition.</p></statement>
    <feedback><p>This is feedback.</p></feedback>
    <cardsort>
        <match>
            <premise order="1">addEdge(fromVert, toVert, weight)</premise>
            <response>Adds a new, weighted, directed edge to the graph that connects two vertices.</response>
        </match>
        <match>
            <premise order="2">getVertex(vertKey)</premise>
            <response>finds the vertex in the graph named vertKey.</response>
        </match>
        <match>
            <premise order="6">getVertices()</premise>
            <response>returns the list of all vertices in the graph.</response>
        </match>
        <match>
            <premise order="3">in</premise>
            <response>returns True for a statement of the form vertex in graph, if the given vertex is in the graph, False otherwise.</response>
        </match>
    </cardsort>
</exercise>

</reading-questions>
</section>

